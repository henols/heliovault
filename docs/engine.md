# Engine Guide

This document explains how the runtime engine uses the compiled level blob and how the core systems are expected to work together.

---

## 1) Runtime flow (high level)

- Boot: initialize IRQ, input, inventory, puzzle state, menu, textbox, audio.
- Load level blob: the engine points at a compiled level blob (from `levelc.py`).
- Load start room: use the start room + spawn encoded in the blob header.
- Game loop:
  - read input
  - update player + entities + collisions
  - open the action menu near interactables
  - resolve actions through puzzle conditions + actions
  - update sprites + background

---

## 2) Where level data comes from

- The engine reads a packed binary blob that contains maps, spawns, exits, interactables, and scripts.
- The blob is generated by `tools/levelc.py` and compiled into C via `gen/src/levels/<level>.c`.

Key runtime files:

- `src/level_runtime.c`: wraps the blob and provides helpers
- `src/room.c`: uses blob offsets to access map/spawn/exit/object data
- `src/puzzle.c`: interprets condition/action bytecode
- `include/level_format.h`: binary offsets + helpers (LVL format)
 - `include/tileset_format.h`: binary offsets + helpers (TSET format)

Oscar64 runtime helpers used:

- `c64/joystick.h` for input polling
- `c64/rasterirq.h` for IRQ setup
- `c64/charwin.h` for screen text writes

---

## 3) Room loading and rendering

Room load:

1) Read room directory entry from the blob.
2) Cache offsets for:
   - map
   - spawns
   - exits
   - objects
3) Point `room_map` to the map data.
4) Render full room on load.

Rendering:

- Map is 20x12 metatiles (40x24 chars).
- Each metatile expands to 2x2 chars.
- Full redraw on room load; use dirty updates for swaps later.

---

## 4) Interactables and the action menu

Interactables are table entries with:

- position (metatile coords)
- verb mask (LOOK/TAKE/USE/TALK/OPERATE)
- condition script offset
- action script offsets per verb

The menu flow:

1) Find object near player (tile or tile in front).
2) Check conditions (`puzzle_conditions_pass`).
3) Show verbs enabled by the object.
4) When a verb is selected, run the action script.

---

## 5) Puzzle system (conditions + actions)

Conditions are AND-only checks:

- flag set/clear
- has item
- var equals

Actions execute in order:

- show message
- set/clear flag
- give/take item
- set variable
- play SFX
- transition to room

These are bytecode scripts stored in the blob and interpreted by `src/puzzle.c`.

---

## 6) Room transitions

- Exits are stored as edge entries or transition actions.
- Transition actions call `room_load_with_spawn(room, spawn)`.
- Spawn positions are stored in the blob per room.

---

## 7) Example: Use a panel to unlock an exit

1) Player uses fuse on panel.
2) Action script sets `FLAG_POWER_ON`.
3) Action script shows "POWER ON".
4) Another action script or condition unlocks the door.
5) Player operates the door â†’ transition action runs.

This keeps logic in data, not hardcoded.

---

## 8) Using generated blobs in code

Level blobs:

```c
#include "level_runtime.h"
#include "room.h"

extern const uint8_t boot_audit_blob[];

void game_load_level(void) {
    level_set_blob(boot_audit_blob);
    room_load_with_spawn(level_get_start_room(), level_get_start_spawn());
}
```

Tilesets + rendering:

```c
#include "metatile.h"
#include "render.h"

void game_init_render(void) {
    metatile_init();
    render_init();
    render_room();
}
```

Low-level blob access:

```c
#include "level_format.h"

uint16_t map_ofs = lvl_room_map_ofs(level_get_blob(), room_get_id());
```

For byte layouts and offsets, see [docs/binary_formats.md](binary_formats.md).

---

## 9) Example: Minimal menu interaction loop (pseudocode)

```
obj = find_focused_object()
if obj && puzzle_conditions_pass(obj.cond):
  verbs = obj.verbs
  verb = menu_pick(verbs)
  if verb == USE:
    item = inventory_pick()
    route_use(obj, item)
  else:
    puzzle_run_actions(obj.action_for(verb))
```

---

## 9) Files to read next

- [docs/levelc.md](levelc.md) for the level compiler and format
- [docs/architecture.md](architecture.md) for the architecture overview
